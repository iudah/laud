#include <Ubject.h>

#include "../../../c/core/d_narray.r.h"
#define NODE_PROTECTED
#define VAR_PROTECTED
#include "../../core/node.r.static.h"
#include "../../core/var.h"
#include "../../core/var.r.static.h"
#include "reduce.r.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Static function declarations
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#define STATIC_FUNC_DECL

static void *solve_reduce(struct laud_reduce *reduce);

static void *differentiate_reduce(struct laud_reduce *reduce,
                                  uint64_t operand_index,
                                  const struct laud_narray *derivative);

#undef STATIC_FUNC_DECL

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Class Initializer
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CLASS_INIT

static void finish_lib();

const void *LaudReduce = NULL;
const void *LaudReduceClass = NULL;

static void __attribute__((constructor(LAUD_REDUCE_PRIORITY)))
library_initializer(void) {
  if (!LaudReduceClass) {
    LaudReduceClass = LaudVarClass;
  }
  if (!LaudReduce) {
    LaudReduce = init(LaudReduceClass, LaudVar,
                      sizeof(struct laud_reduce),           // class parent size
                      className, "LaudReduce",              // class name
                      laud_evaluate_var_node, solve_reduce, // evaluate_node
                      laud_differentiate_var_node,
                      differentiate_reduce, // differentiate_node
                      NULL);
  }

  atexit(finish_lib);
}

static void finish_lib() { FREE(LaudReduce); }
#undef CLASS_INIT

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Implemention
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IMPL

static void *solve_reduce(struct laud_reduce *reduce) {
  return laud_reduce(narray((struct laud_var *)incoming_nodes(reduce)[0]),
                     reduce->axis, reduce->callback, reduce->args);
}

static void *differentiate_reduce(struct laud_reduce *reduce,
                                  uint64_t operand_index,
                                  const struct laud_narray *derivative) {
  return laud_narray_dreduce(
      narray((struct laud_var *)incoming_nodes(reduce)[0]), operand_index,
      derivative, narray(reduce));
}

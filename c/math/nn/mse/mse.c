#include <Ubject.h>

#define NODE_PROTECTED
#define VAR_PROTECTED
#include "../../../core/d_narray.r.h"
#include "mse.r.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Static function declarations
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#define STATIC_FUNC_DECL

static void *solve_mse(struct laud_mse *mse);

static void *differentiate_mse(struct laud_mse *mse, uint64_t operand_index,
                               const struct laud_narray *derivative);

#undef STATIC_FUNC_DECL

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Class Initializer
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CLASS_INIT

const void *LaudMSE = NULL;
const void *LaudMSEClass = NULL;
static void fini_mse();
static void __attribute__((constructor(LAUD_MSE_PRIORITY)))
library_initializer(void) {
  if (!LaudMSEClass) {
    LaudMSEClass = LaudVarClass;
  }
  if (!LaudMSE) {
    LaudMSE = init(LaudMSEClass, LaudVar,
                   sizeof(struct laud_mse),           // class parent size
                   className, "LaudMSE",              // class name
                   laud_evaluate_var_node, solve_mse, // evaluate_node
                   laud_differentiate_var_node,
                   differentiate_mse, // differentiate_node
                   NULL);
  }
atexit(fini_mse);
}

static void fini_mse(){
    FREE(LaudMSE);
}

#undef CLASS_INIT

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Implemention
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IMPL

void *laud_mse(void *operand_a, void *operand_b) {
  const struct laud_base_class *class = classOf(operand_a);
  return class->mse(operand_a, operand_b, NULL);
}

static void *solve_mse(struct laud_mse *mse) {
  return laud_mse(narray((struct laud_var *)incoming_nodes(mse)[0]),
                  narray((struct laud_var *)incoming_nodes(mse)[1]));
}

static void *differentiate_mse(struct laud_mse *mse,
                               const uint64_t operand_index,
                               const struct laud_narray *derivative) {
  return laud_narray_dmse(narray((struct laud_var *)incoming_nodes(mse)[0]),
                          narray((struct laud_var *)incoming_nodes(mse)[1]),
                          operand_index, derivative, narray((const void *)mse));
}